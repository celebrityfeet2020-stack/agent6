"""Speech Recognition Tool - OpenAI Whisper API"""
from langchain_core.tools import BaseTool
from typing import Optional
import os
import requests


class SpeechRecognitionTool(BaseTool):
    name: str = "speech_recognition"
    description: str = """Transcribe audio files to text using OpenAI Whisper API.
    
    Supported formats: mp3, mp4, mpeg, mpga, m4a, wav, webm
    Max file size: 25 MB
    
    Input should be a file path to an audio file.
    Returns the transcribed text."""
    
    api_key: Optional[str] = None
    api_base: str = "https://api.openai.com/v1"
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        # Get API key from environment
        self.api_key = os.getenv("OPENAI_API_KEY")
        if not self.api_key:
            print("[WARNING] OPENAI_API_KEY not set, Speech Recognition tool may not work")
    
    def _run(self, audio_path: str, language: str = None, prompt: str = None) -> str:
        """
        Transcribe audio file to text.
        
        Args:
            audio_path: Path to audio file
            language: Optional ISO-639-1 language code (e.g., 'en', 'zh')
            prompt: Optional text to guide the model's style
        
        Returns:
            Transcribed text or error message
        """
        try:
            # Check if file exists
            if not os.path.exists(audio_path):
                return f"Audio file not found: {audio_path}"
            
            # Check file size (25 MB limit)
            file_size = os.path.getsize(audio_path)
            if file_size > 25 * 1024 * 1024:
                return f"File too large: {file_size / (1024*1024):.2f} MB (max 25 MB)"
            
            # Check file format
            supported_formats = ['mp3', 'mp4', 'mpeg', 'mpga', 'm4a', 'wav', 'webm']
            file_ext = os.path.splitext(audio_path)[1].lower().lstrip('.')
            if file_ext not in supported_formats:
                return f"Unsupported format: {file_ext}. Supported: {', '.join(supported_formats)}"
            
            # Check API key
            if not self.api_key:
                return "Error: OPENAI_API_KEY not configured"
            
            # Prepare request
            url = f"{self.api_base}/audio/transcriptions"
            headers = {
                "Authorization": f"Bearer {self.api_key}"
            }
            
            # Prepare form data
            with open(audio_path, 'rb') as audio_file:
                files = {
                    'file': (os.path.basename(audio_path), audio_file, f'audio/{file_ext}')
                }
                data = {
                    'model': 'whisper-1'
                }
                
                # Add optional parameters
                if language:
                    data['language'] = language
                if prompt:
                    data['prompt'] = prompt
                
                # Make request
                response = requests.post(
                    url,
                    headers=headers,
                    files=files,
                    data=data,
                    timeout=120  # 2 minutes timeout
                )
            
            # Check response
            if response.status_code == 200:
                result = response.json()
                transcription = result.get('text', '')
                
                output = f"=== Transcription ===\n{transcription}\n\n"
                output += f"File: {os.path.basename(audio_path)}\n"
                output += f"Size: {file_size / 1024:.2f} KB\n"
                output += f"Format: {file_ext.upper()}"
                
                return output
            else:
                error_msg = response.text
                try:
                    error_json = response.json()
                    error_msg = error_json.get('error', {}).get('message', error_msg)
                except:
                    pass
                return f"API Error ({response.status_code}): {error_msg}"
                
        except requests.exceptions.Timeout:
            return "Error: Request timeout (audio file may be too long)"
        except requests.exceptions.RequestException as e:
            return f"Network error: {str(e)}"
        except Exception as e:
            return f"Error transcribing audio: {str(e)}"
    
    async def _arun(self, audio_path: str, language: str = None, prompt: str = None) -> str:
        """Async version - calls sync version for now"""
        return self._run(audio_path, language, prompt)
